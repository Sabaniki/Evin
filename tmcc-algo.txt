私達は、この問題を解決するにあたり、様々なことを考察・検証し、プログラムの作成にあたった。

まず、この問題について私達が着目したのは、2級問題の回答にも使ったアルゴリズム「バックトラック法」である。

最初に完成したプログラムの流れを大まかに説明する。


(a-1).25×25の座標平面に見立てた2次配列を作成する。
(a-2).そこから任意の長さに適した座標平面になるように配列を調節する。

(a-3).原点を配列上で(12,12)と仮定し、その隣の(13,12)からバックトラック法を開始する。
(a-4).(a-3)の動作によりひとつのSALが求まる。するとこのSALと同じようなSALが(12,13)方向、(11,12)方向、(12,11)方向にそれぞれ1つずつ存在すると考えられ、これらが本当にSALか調査するために、障害物を座標平面上で90°回転するようにしてSALの軌跡に該当するか比較する。

(a-5).該当した通り分答えを保存する変数Ansを加算する。

(a-6).(a-4)と(a-5)と同様な動作を繰り返し行い、全てを探索し終えたら答えを出力する。



次にバックトラック法について詳しく説明する。バックトラック法とは深さ優先探索の一種で今回私達はこれを基礎としてアルゴリズムを構築した。

(b-1).進める方向にとりあえず進み、通ったかところの配列1にする。

(b-2).それが長さ20になった時、最後の点が自分が通った奇跡を除く原点周辺の3点どれかにいるか判断をする。

(b-3).(a-4)にある考え方で障害物を回転させて評価する。

(b-4).同様に全てのSALを探索する。

以上がバックトラック法である。

他にも(a-1)(a-2)の動作はSALはループするという条件を利用したものである。もし入力された長さの半分以上はなれると、そのSAWは原点に戻って来ることが不可能になる。それを評価するためにあらかじめ入力に対して座標平面に壁を作成してそれ以上先を探索しないようにしている。
他にも、SALが半分から先に行ったところでマンハッタン法を使って原点からの距離を調査し、進める長さよりマンハッタン距離が長いとSALになることはない。
その条件を加えて、処理を軽減した。